<!DOCTYPE HTML>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <style>
   body {
     margin: 0px;
      padding: 0px;
       font-family: sans-serif;
   }
   #display_image {
     border: 1px solid #9C9898;
   }
  </style>
  <script language="JavaScript" src="js/gradient_data.js"></script>
  <script>

    var STOREDIMAGE = new Image(); // Store the image data apart from the canvas

    window.onload = function() {

        imageFromURL("../sample/deposition/paper_fig1d_magnified.png");  // TODO remove

        var k;
        for (k in lowCycle){
            addGradient(k, lowCycle[k]);
        }
        for (k in midCycle){
            addGradient(k, midCycle[k]);
        }
        for (k in highCycle){
            addGradient(k, highCycle[k]);
        }
    };

    function imgToCanvas(imgData){
        // When an image is loaded, update the canvas drawing

        console.log("Event firing");

        var canvas = document.getElementById('display_image');
        var ctx = canvas.getContext('2d');

        canvas.width = imgData.width;
        canvas.height = imgData.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.drawImage(imgData, 0, 0);

        greyScaleImg(canvas);
    }

    function imageFromURL(url){
        //var imgData = new Image();
        STOREDIMAGE = null;
        STOREDIMAGE = new Image();
        STOREDIMAGE.onload = function(){imgToCanvas(this)};

        STOREDIMAGE.crossOrigin = 'anonymous';

        STOREDIMAGE.src = url;

        // TODO: Why is this hack necessary? onload doesn't always fire
        imgToCanvas(STOREDIMAGE);
    }


    function imageFromFileBlob(blob){
        if (!blob.type.match("image.*")) {
            console.log('Specified file blob is not an image')
        } else {
            var canvas = document.getElementById('display_image');

            var reader = new FileReader();
            /// Load file data to the image object that FabricJS requires
            reader.onload = function(event){

                STOREDIMAGE = null;
                STOREDIMAGE = new Image();
                STOREDIMAGE.onload = function(){imgToCanvas(this)};

                STOREDIMAGE.crossOrigin = 'anonymous';

                STOREDIMAGE.src = event.target.result;

                // TODO: Why is this hack necessary? onload not firing = grr
                imgToCanvas(STOREDIMAGE);
            };
            reader.readAsDataURL(blob);
        }
    }

    function renderFile(event){
        var img_blob = event.target.files[0];
        imageFromFileBlob(img_blob);
    }


     function addGradient(grad_name, color_stops){
         // Add a new rectangular canvas with fill representing specified gradient
         var gradientBox = document.getElementById("gradients");

         var grdCanvas = document.createElement("canvas");
         grdCanvas.width = 256;
         grdCanvas.height = 20;

         var ctx = grdCanvas.getContext('2d');
         var grd = ctx.createLinearGradient(0, 0, grdCanvas.width, 0);

         for (var i=0; i < color_stops.length; i++){
             grd.addColorStop(color_stops[i][0], color_stops[i][1]);
         }
         ctx.fillStyle = grd;
         ctx.fillRect(0, 0, grdCanvas.width, grdCanvas.height);

         var container = document.createElement('div');
         var label = document.createTextNode(grad_name);
         container.appendChild(label);
         container.appendChild(grdCanvas);
         gradientBox.appendChild(container);

         // Add event listener only after gradient filled in
         grdCanvas.onclick = function(){ recolorImg(grdCanvas); //recolorImg(grdCanvas)
         };

         // TODO Implement putimagedata() to change data on canvas later
         // TODO: implement display of chosen gradients
     }

    function greyScaleImg(canvas){
        // Given a canvas rendering of an image, convert to greyscale
        // This algorithm only works if the image starts out in greyscale
        var ctx = canvas.getContext("2d");

        //grayscale the image
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var data = imageData.data;

        for(var i = 0; i < data.length; i += 4) {
            var brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            //YUV -> PAL/NTSC
            //var brightness = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
            data[i] = brightness; // red
            data[i + 1] = brightness; // green
            data[i + 2] = brightness; // blue
        }
        ctx.putImageData(imageData,0,0);
    }

    function saveCanvas(linkEl){
        // Save the modified/ recolored image data to a file
        var canvas = document.getElementById("display_image");
        linkEl.href = canvas.toDataURL('image/png');
    }

     function recolorImg(grdCanvas){
         // Apply the given gradient data to an image
         imgToCanvas(STOREDIMAGE); // Always recolor from original image to avoid loss of color when two gradients applied in sequence

         var imgCvs = document.getElementById("display_image");
         var imgCtx = imgCvs.getContext('2d');
         var imgData = imgCtx.getImageData(0, 0, imgCvs.width, imgCvs.height);


         var imgOrig = imgData.data;
         var imgRecolor = imgData.data;

         var grdCtx = grdCanvas.getContext('2d');
         var grdData = grdCtx.getImageData(0, 0, grdCanvas.width, grdCanvas.height);
         var grdArr = grdData.data;

         // TODO: for every pixel in array,
         // colorization method from: http://podeplace.blogspot.com/2012/12/pseudocolorisation-with-javascript.html
         for(var y = 0; y < imgCvs.height; y++) {
             for (var x = 0; x < imgCvs.width; x++) {
                 var index = (x + y * imgCvs.width) * 4;

                 //we grab the color from one channel (the red one)
                 var luminosityValue = imgOrig[index + 0];

                 //we retrieve the corresponding (R,G,B) triplet from the colormap
                 //we rewrite the new color
                 imgRecolor[index + 0] = grdArr[luminosityValue * 4 + 0]; //R
                 imgRecolor[index + 1] = grdArr[luminosityValue * 4 + 1]; //G
                 imgRecolor[index + 2] = grdArr[luminosityValue * 4 + 2]; //B
                 //dataRes[index+3] = 255; //no need to change alpha value
             }}
         imgData.data = imgRecolor;
         imgCtx.putImageData(imgData, 0, 0);

        // TODO: reimplement this as a new fabric filter for every gradient a la redify implementation
     }
  </script>
</head>
<body>
  <div>
      <canvas id="display_image"></canvas>
  </div>

  <form>
    <p>Select an image file to preview: <input type="file" id="pick_image" onchange="renderFile(event)"/></p>
      <p><a href="#" onclick="saveCanvas(this)" download="recolor.png">Save image data</a></p>
      <!-- TODO: This feature doesn't seem to work for remote urls; no error messages
        <p> OR enter the URL of an image on the web: <input type="text" onchange="imageFromURL(this.value)"/></p>
      -->
  </form>

  <div id="gradients"></div>
</body>
</html>
